import { error, redirect } from '@sveltejs/kit';
import { StatusCodes } from 'http-status-codes';

import { makeNewParticipantId } from '$lib/server/participants';
import {
    getParticipationCode,
    saveParticipant,
    setParticipantAssignments
} from '$lib/server/database';
import { validateParticipationCode } from '$lib/server/validate-participation-codes';
import type { ClassroomId } from '$lib/server/newtypes';
import { CONDITIONS, type Assignment, type Condition, TASK_NAMES } from '$lib/types';

export const actions: import('./$types').Actions = {
    /**
     * Handles the POST from the consent form. With the participant's consent,
     * we store their data, and give them a cookie to track their requests.
     *
     * Presently, the participation ID must be checked here, so that we don't
     * have to validate it anywhere else.
     */
    default: async ({ params, request, cookies }) => {
        const classroom = params.classroom as ClassroomId;

        const storedParticipationCode = await getParticipationCode(classroom);
        if (storedParticipationCode == null)
            throw error(StatusCodes.NOT_FOUND, 'The classroom was not found.');

        const data = await request.formData();

        // Check that the participant has consented to all:
        if (data.get('consentedToAll') !== 'true')
            throw error(
                StatusCodes.BAD_REQUEST,
                'You must consent to all of the above to participate.'
            );

        // Make sure the participation code were specified:
        if (!data.has('participation_code'))
            throw error(StatusCodes.BAD_REQUEST, 'The participation code was not specified.');
        const participationCode = data.get('participation_code') as string;

        // Check that the participation code is correct before continuing:
        const codeOk = await validateParticipationCode(storedParticipationCode, participationCode);
        if (!codeOk) throw error(StatusCodes.BAD_REQUEST, 'The participation code was incorrect.');

        const participantID = makeNewParticipantId();

        await saveParticipant(participantID, classroom);
        cookies.set('participant_id', participantID, { path: '/' });

        // Give the participant their assignments:
        // TODO: should this be done in a later stage?
        const assignments = assignmentGenerator.next().value;
        if (assignments == null)
            throw error(StatusCodes.INTERNAL_SERVER_ERROR, 'Could not generate assignments');
        await setParticipantAssignments(participantID, assignments);

        throw redirect(StatusCodes.SEE_OTHER, '/questionnaire');
    }
};

// Internal functions

const assignmentGenerator = generateAssignments();

/**
 * Infinite generator of all possible assignments.
 *
 * This generate will return random assignments, but ensures that all possible
 * assignments are equally likely. That is, task and condition are both randomly
 * assigned, but counterbalanced.
 *
 * NOTE: assignments will be counterbalanced AS LONG AS only one server process
 * is creating the assignments and does not restart between all assignments!
 */
function* generateAssignments(): Generator<Assignment[], undefined, undefined> {
    const allPossibleAssignments = [];
    for (const taskOrder of permutations(TASK_NAMES)) {
        for (const prezOrder of permutations(CONDITIONS)) {
            const assignments: Assignment[] = taskOrder.map((task, index) => ({
                task,
                condition: prezOrder[index] as Condition
            }));
            allPossibleAssignments.push(assignments);
        }
    }

    while (true) {
        shuffle(allPossibleAssignments);
        yield* allPossibleAssignments;
    }
}

// Fisher-Yates shuffle, as generated by GitHub Copilot.
// It starts from the end, which is not the way I usually implement it,
// but it honestly do not matter.
function shuffle<T>(array: T[]): T[] {
    for (let i = array.length - 1; i > 0; i--) {
        // i + 1 so that we randomly pick to swap the element with itself.
        // (hint: you're supposed to be able to swap an element with itself, or
        //  else you're not shuffling properly).
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

// Returns an array of all permutations of the given array.
// Generated by GitHub Copilot.
function permutations<T>(array: readonly T[]): T[][] {
    if (array.length <= 1) return [[...array]];

    const result = [];
    for (let i = 0; i < array.length; i++) {
        const element = array[i];
        // Slice out the current element.
        const rest = array.slice(0, i).concat(array.slice(i + 1));
        // Recurse to get permutations of the rest of the array.
        const restPermutations = permutations(rest);
        for (const perm of restPermutations) {
            result.push([element, ...perm]);
        }
    }
    return result;
}
