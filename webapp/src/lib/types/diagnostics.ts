import type { MarkdownString } from '$lib/server/newtypes';
import type { JsonMarkerData } from '.';

/**
 * The different types of diagnostics that can be associated with code that is
 * compiled and run by oq.
 *
 * This is a discriminated union, with `format` as the discriminator.
 * See: https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions
 */
export type Diagnostics =
    | PreformattedDiagnostic
    | GCCDiagnostics
    | PythonDiagnostics
    | RustDiagnostics
    | LLMEnhancedDiagnostics
    | MarkdownDiagnostics
    | ManuallyEnhancedDiagnostic;

/**
 * Plain-text diagnostics with pre-formatted text.
 */
export interface PreformattedDiagnostic {
    format: 'preformatted';
    plainText: string;
}

/**
 * Diagnostics generated by GCC using -fdiagnostics-format=json.
 */
export interface GCCDiagnostics {
    format: 'gcc-json';
    diagnostics: RootGCCDiagnostic[];
}

/**
 * Diagnostics parsed from a Python traceback.
 */
export interface PythonDiagnostics {
    format: 'parsed-python';
    diagnostics: PythonTraceback;
}

/**
 * Diagnostics generated by rustc using --error-format=json.
 */
export interface RustDiagnostics {
    format: 'rustc-json';
    diagnostics: RootRustDiagnostic[];
}

/**
 * Diagnostics that were "enhanced" by an LLM. These will always contain the
 * original diagnostics.
 */
export interface LLMEnhancedDiagnostics {
    format: 'llm-enhanced';
    markdown: MarkdownString;
    original: Diagnostics;
}

/**
 * Diagnostics that were manually enhanced by a human.
 * These will always be written in Markdown.
 * Currently (2023-01-20), you can find these in webapp/tasks/
 */
export interface ManuallyEnhancedDiagnostic {
    format: 'manually-enhanced';
    markdown: MarkdownString;
    markers: JsonMarkerData[];
}

/**
 * Diagnostics that should be rendered as plain Markdown.
 */
export interface MarkdownDiagnostics {
    format: 'markdown';
    markdown: MarkdownString;
}

/**
 * See: https://gcc.gnu.org/onlinedocs/gcc-11.1.0/gcc/Diagnostic-Message-Formatting-Options.html
 */
export interface GCCDiagnostic {
    kind: 'error' | 'warning' | 'note';
    /**
     * The human-readable diagnostic message.
     */
    message: string;
    /**
     * If [kind] is 'warning', then there is an option key describing the command-line option controlling the warning.
     */
    option?: string;
    /**
     * A diagnostic can contain zero or more locations.
     */
    locations: GCCLocation[];
    /**
     * Diagnostics can have child diagnostics.
     * Eddie says: "This will often be a 'note' that provides some additional context".
     */
    children: GCCDiagnostic[];
    /**
     * [Hints] whether non-ASCII bytes should be escaped when printing the
     * pertinent lines of source code (true for diagnostics involving source
     * encoding issues).
     */
    'escape-source': boolean;
}

/**
 * A non-child GCC diagnostic. This will contain the column-origin field.
 */
export interface RootGCCDiagnostic extends GCCDiagnostic {
    /**
     * What kind of indexing to use for the column numbers in the locations.
     * GCC defaults to 1-based indexing, but can be configured to use 0-based indexing.
     *
     * @since gcc 11.1.0
     */
    'column-origin'?: number;
}

interface GCCLocation {
    /**
     * Each location has an optional label string and up to three positions within it: a caret position and optional start and finish positions.
     */
    label?: string;
    /**
     * The primary position of a location (where you would put the ^ when printing the message).
     */
    caret: GCCPosition;
    /**
     * Eddie says: "I have never seen GCC generate a start position outside a fixit hint"
     */
    start?: GCCPosition;
    /**
     * A position to the right of the caret.
     */
    finish?: GCCPosition;
}

interface GCCPosition {
    /**
     * A position is described by a file name, a line number, and three numbers indicating a column position.
     */
    file: string;

    /**
     * Line numbers are 1-based.
     */
    line: number;
    /**
     * display-column counts display columns, accounting for tabs and multibyte characters.
     */
    'display-column'?: number;
    /**
     * byte-column counts raw bytes.
     */
    'byte-column'?: number;
    /**
     * column is equal to one of the previous two, as dictated by the -fdiagnostics-column-unit option.
     */
    column: number;
}
/**
 * See also: https://github.com/python/cpython/blob/3.12/Lib/traceback.py#L679
 */
export interface PythonTraceback {
    hasTraceback: boolean;
    exception: string;
    message: string;
    frames: PythonFrame[];
}
/**
 * See also: https://github.com/python/cpython/blob/3.12/Lib/traceback.py#L248
 */

export interface PythonFrame {
    filename: string;
    startLineNumber: number;
    /** The name of the function, method, or module for this frame. */
    name?: string;
    /** The line of source code, WITH LEADING WHITESPACE REMOVED! */
    line?: string;
    /** Error squiggles, perfectly aligned under the line. */
    marker?: string;
}

/**
 * The documentation for this and all related interfaces is taken from here:
 * https://doc.rust-lang.org/rustc/json.html#diagnostics
 */
export interface RustDiagnostic {
    /* EDDIE'S NOTE: the above link claims that there is a property called
     * '$message_type' and it is always set to 'diagnostic', but in practice,
     * this property does not seem to be present. Also, it's completely useless. */

    /** The primary message. */
    message: string;
    /** The diagnostic code. Some messages may set this value to null. */
    code: RustDiagnosticCode | null;
    /** The severity of the diagnostic.
     * Values may be:
     * - "error": A fatal error that prevents compilation.
     * - "warning": A possible error or concern.
     * - "note": Additional information or context about the diagnostic.
     * - "help": A suggestion on how to resolve the diagnostic.
     * - "failure-note": A note attached to the message for further information.
     * - "error: internal compiler error": Indicates a bug within the compiler.
     */
    level:
        | 'error'
        | 'warning'
        | 'note'
        | 'help'
        | 'failure-note'
        | 'error: internal compiler error';
    /**
     * An array of source code locations to point out specific details about
     * where the diagnostic originates from. This may be empty, for example
     * for some global messages, or child messages attached to a parent.
     *
     * Character offsets are offsets of Unicode Scalar Values.
     */
    spans: RustSpan[];
    /**
     * Optional string of the rendered version of the diagnostic as displayed
     * by rustc. Note that this may be influenced by the `--json` flag.
     *
     * EDDIE'S NOTE: I have used the rustc flags:
     *  rustc --error-format=json --json=diagnostic-rendered-ansi
     *
     * The rendered text SHOULD exist and have ANSI color codes.
     */
    rendered: string | null;
}

export interface RootRustDiagnostic extends RustDiagnostic {
    /**
     * Array of attached diagnostic messages.
     * This is an array of objects using the same format as the parent
     * message. Children are not nested (children do not themselves
     * contain "children" definitions).
     */
    children: RustDiagnostic[];
}

export interface RustDiagnosticCode {
    /** A unique string identifying which diagnostic triggered. */
    code: string;
    /** An optional string explaining more detail about the diagnostic code. */
    explanation: string | null;
}

interface RustSpan {
    /**
     * The file where the span is located.
     * Note that this path may not exist. For example, if the path
     * points to the standard library, and the rust src is not
     * available in the sysroot, then it may point to a nonexistent
     * file. Beware that this may also point to the source of an
     * external crate.
     */
    file_name: string;
    /** The byte offset where the span starts (0-based, inclusive). */
    byte_start: number;
    /** The byte offset where the span ends (0-based, exclusive). */
    byte_end: number;
    /** The first line number of the span (1-based, inclusive). */
    line_start: number;
    /** The last line number of the span (1-based, inclusive). */
    line_end: number;
    /** The first character offset of the line_start (1-based, inclusive). */
    column_start: number;
    /** The last character offset of the line_end (1-based, exclusive). */
    column_end: number;
    /**
     * Whether or not this is the "primary" span.
     *
     * This indicates that this span is the focal point of the
     * diagnostic.
     *
     * There are rare cases where multiple spans may be marked as
     * primary. For example, "immutable borrow occurs here" and
     * "mutable borrow ends here" can be two separate primary spans.
     *
     * The top (parent) message should always have at least one
     * primary span, unless it has zero spans. Child messages may have
     * zero or more primary spans.
     */
    is_primary: boolean;
    /**
     * An array of objects showing the original source code for this span.
     * This shows the entire lines of text where the span is located.
     * A span across multiple lines will have a separate value for each line.
     */
    text: RustSourceCodeLine[];
    /**
     * An optional message to display at this span location.  This is typically
     * null for primary spans.
     */
    label: string | null;
    /**
     * An optional string of a suggested replacement for this span to solve the issue.
     * Tools may try to replace the contents of the span with this text.
     */
    suggested_replacement: string | null;
    /**
     * An optional string that indicates the confidence of the "suggested_replacement".
     * Tools may use this value to determine whether or not suggestions should be automatically applied.
     *
     * Possible values may be:
     * - "MachineApplicable": The suggestion is definitely what the user intended.
     *   This suggestion should be automatically applied.
     * - "MaybeIncorrect": The suggestion may be what the user intended, but it is uncertain.
     *   The suggestion should result in valid Rust code if it is applied.
     * - "HasPlaceholders": The suggestion contains placeholders like `(...)`.
     *   The suggestion cannot be applied automatically because it will not result in valid Rust code.
     *   The user will need to fill in the placeholders.
     * - "Unspecified": The applicability of the suggestion is unknown.
     */
    suggestion_applicability:
        | 'MachineApplicable'
        | 'MaybeIncorrect'
        | 'HasPlaceholders'
        | 'Unspecified';
    /**
     * An optional object indicating the expansion of a macro within
     * this span.
     *
     * If a message occurs within a macro invocation, this object will
     * provide details of where within the macro expansion the message
     * is located.
     */
    expansion: RustMacroExpansion | null;
}

interface RustSourceCodeLine {
    /** The entire line of the original source code. */
    text: string;
    /**
     * The first character offset of the line of where the span covers this line
     * (1-based, inclusive).
     */
    highlight_start: number;
    /**
     * The last character offset of the line of where the span covers this line (1-based, exclusive).
     */
    highlight_end: number;
}

interface RustMacroExpansion {
    /**
     * The span of the macro invocation.
     * Uses the same span definition as the "spans" array.
     */
    span: RustSpan;
    /**
     * Name of the macro, such as "foo!" or "#[derive(Eq)]".
     */
    macro_decl_name: string;
    /**
     * Optional span where the relevant part of the macro is defined.
     */
    def_site_span: RustSpan | null;
}
